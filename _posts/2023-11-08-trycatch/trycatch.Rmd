---
title: "Using tryCatch() (within simulations)"
description: |
  I had previously found the structure of tryCatch() difficult: cracked it!
author:
  - name: Chris Evans
    url: https://www.psyctc.org/R_blog/
    affiliation: PSYCTC.org
    affiliation_url: https://www.psyctc.org/psyctc/
    orcid_id: 0000-0002-4197-4202
preview: "css.png"
date: 2023-11-08
categories:
  - R tricks
  - simulation
output:
  distill::distill_article:
    toc: true
    toc_depth: 4
    hightlight_downlit: true
    self_contained: false
    code_folding: true
creative_commons: CC BY-SA
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = TRUE)

library(tidyverse)
library(CECPfuns)
library(flextable)

### set ggplot theme defaults
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = .5), 
             plot.subtitle = element_text(hjust = .5)) 
```

# What is tryCatch()

The tryCatch() function is part of base R and provides a wrapper around another function that, as the name says, tries that function and catches errors or warnings when it is run.  

## Why this post?!

Because I don't find the help for tryCatch() very helpful at all, to me, like quite a bit that I found when I searched the web about tryCatch(), it seemed to be written by people who understood it for people who are much more immersed in some of the more subtle and advanced aspects of R than I use.  So this is partly to remind me of what I've just taught myself, which I will forget as I don't use tryCatch() all that often.  I hope it will also be useful to others.

## Why use tryCatch()?

I can see that I might want to use this to put different error or warning messages in some of my [CECPfuns package](https://github.com/cpsyctc/CECPfuns) of functions that are designed to make it easier for therapy and mental health practitioners and researchers who are not statisticians or R experts to use R's enormous strengths: some R functions, however amazing, can return errors and warnings that can be confusing for the my user group (and me!)  

However, my main need for tryCatch() comes when I am creating simulations as sometimes these cannot be analysed and so returns an error.  Unless you trap the error this will crash the simulation: frustrating if it's been running for hours and is on the 997th iteration of a planned 1,000!  What I want is for the simulation to absorb the error, return missing values for whatever format of return value that function was going to return, and for the simulation to keep running.  That's what tryCatch() does!  (It also means that in this little post I'm only covering how tryCatch() handles errors, not warnings, a warning coming back during a simulation run doesn't worry me as it won't crash the run. There is a lot more that tryCatch() can do that I am also skipping as those things aren't pertinent for me.)

## Very simple example

Hm, it's surprisingly difficult to find really simple functions in R that don't actually already do sensible things with mad inputs, usually returning NA or NaN ("Not a Number") and a warning so not crashing a simulation.  Trust me, complicated analyses such some psychometric and bootstrap ones can, not unreasonably, just return an error and stop even on data coming from simulations (and real data).

OK, here's a silly example, suppose my function wants to get the 5th and 95% quantiles of the first principal component of simulated repertory grids allowing that number of elements.

(I have written the function to show the first simulated grid so you see what's happening.)

```{r simulation1}
simulateGridPC1v1 <- function(nCons, nElem, minScore, maxScore, nSims) {
  ### vector to store PCs
  vecPCs <- rep(NA, nSims)
  for (i in 1:nSims) {
    tmpMat <- matrix(sample(minScore:maxScore, nCons * nElem, replace = TRUE), nrow = nCons)
    if (i == 1){
      ### print the first simulated grid to give the idea of the simulation
      print("Here is the first simulated grid")
      print(tmpMat)
      print(" ")
    }
    ### get the first principal component of that simulated grid
    ### yes, I used princomp() with cor = TRUE to make problems likely!
    vecPCs[i] <- princomp(tmpMat, cor = TRUE)$sdev[1]
  }
  print("Here are the first PC values:")
  print(vecPCs)
  ### but we just want the 5th and 95th quantiles of the first principal components
  ### of the nSims simulated grids:
  print("Finally the quantiles:")
  quantile(vecPCs, c(.05, .95))
}
set.seed(1234) # make simulation replicable
simulateGridPC1v1(5, 5, 0, 2, 10) # 5 constructs but only 5 elements and 0, 1, 2 scoring
```

So that worked for that silly little simulation run with only 10 iterations.  We need more iterations for sensible estimation of those quantiles, let's go to 10,000 iterations.

```
set.seed(12345) # replicability (in principle)
simulateGridPC1v1(5, 5, 0, 2, 10000)
```

But that just gives this:
```
Quitting from lines 84-86 [simulation2] (trycatch.Rmd)
Error in `princomp.default()`:
! cannot use 'cor = TRUE' with a constant variable
Backtrace:
 1. global simulateGridPC1v1(5, 5, 0, 2, 10000)
 3. stats:::princomp.default(tmpMat, cor = TRUE)
Execution halted
```

So that crashed on some iteration of that function.  It crashed because one of the elements came up with no variance, i.e. all the randomly simulated scores on that element were 1 (or were all 0).

# Use tryCatch() to prevent that crashing

What I've done is to write a little function `tryGetPC1()` to replace the call `princomp(tmpMat, cor = TRUE)$sdev[1]`.

```{r simulation3}
### 
### tryCatch() bit
###
tryGetPC1 <- function(tmpMat) {
  retVal <- tryCatch(
    {
      ### if this call to princomp() runs without error the function will just return the answer from that call
      return(princomp(tmpMat, cor = TRUE)$sdev[1])
      ### however ...
    },
    ### that comma at the end of that line takes us into what to do if that call failed with an error
    error = function() { 
      return(NA)
    }
    ### we could have another comma and a new line saying what to do if the call ran but threw a warning
    ### but I don't need that
  ) # end of tryCatch() call
}

### now I embed that in the simulation function
simulateGridPC1v2 <- function(nCons, nElem, minScore, maxScore, nSims) {
  ### vector to store PCs
  vecPCs <- rep(NA, nSims)
  for (i in 1:nSims) {
    tmpMat <- matrix(sample(minScore:maxScore, nCons * nElem, replace = TRUE), nrow = nCons)
    ### get the first principal component of that simulated grid
    ### yes, I used princomp() with cor = TRUE to make problems likely!
    vecPCs[i] <- tryGetPC1(tmpMat)
  }
  ### but we just want the 5th and 95th quantiles of the first principal components
  ### of the nSims simulated grids:
  ### need to allow missing values in quantile now
  return(cat("That simulation run gave:\n   n(unusuable simulations) = ", sum(is.na(vecPCs)),
             "\n   n(usable simulations) = ", sum(!is.na(vecPCs)),
             "\nand quantiles:",
             "\n   q05 = ", round(quantile(vecPCs, .05, na.rm = TRUE), 4),
             "\n   q95 = ", round(quantile(vecPCs, .95, na.rm = TRUE), 4)))
}
set.seed(1234) # make simulation replicable
### this should work as we know, from using simulateGridPC1v1 that these five simulations 
### don't throw errors
simulateGridPC1v2(5, 5, 0, 2, 10) # 5 constructs but only 5 elements and 0, 1, 2 scoring
```

But now we can handle simulated grids that can't be crunched to give a first PC:

```{r simulation4}
set.seed(12345) # replicability (in principle)
simulateGridPC1v2(5, 5, 0, 2, 10000)
```

So we can see that 608 of those simulations would have crashed the run but with the tryCatch() the error is caught and the PC is replaced with NA.

# What if the return value is more complex than a single number?

I needed to use this for simulation involving bootstrap CI estimates and which return something more complex than a single value.  I realised that there are two sensible ways to handle that:

* capture the full output from a run of the call that doesn't throw and error and use dput() to get its structure then use that listing from dput to create a return in which you replace the bits that need to be replaced with NA.

* probably better:

  + either write a wrapper around the call you are using that returns something complex and just get the bits you want 
  
  + or just pull out what you want in the first bit of the tryCatch() call

Here's an example extracting the bits of a percentile bootstrap CI call:

```
 ### first the percentile method
  getPercCI <- function(tmpBootRes, conf = conf){
    tryCatch({
        tmpCI <- boot::boot.ci(tmpBootRes, type = 'perc', conf = conf)
        ### here just pick the bits you want to return
        return(list(percLCLCSC = tmpCI$percent[4],
                    percUCLCSC = tmpCI$percent[5]))
      },
      error = function(tmp) {
        tmp <- NA
        ### return the same structured named list but with NA values
        return(list(percLCLCSC = NA,
                    percUCLCSC = NA))
      }
    )
  }
```

